# Командная строка

<!-- Важность навыка работы в командной строке -->
Умение работать в командной строке -- важнейший навык, которым должен обладать каждый разработчик программ.
В среде Windows он маловостребован, так как в ней классические консольные утилиты облачены в графический интерфейс.
Но в среде UNIX без командной строки не обойтись.
Она участвует в автоматизации рутинных действий и решении специфический задач.

<!-- Где используют командную строку -->
Командная строка -- это основной инструмент при администрировании ОС и сети.
Но вам, как разработчикам ПО, она понадобится при
* установке дополнительных программ;
* настройке окружения разработки;
* сборке программ из исходных кодов;
* автоматизации рутинных действий.

<!-- Что узнаем? -->
В результате обучения вы:
* разберете формат командной строки;
* разберете возможности эмулятора терминала `GNOME Terminal`;
* научитесь эффективно редактировать строки в терминале.


## Формат командной строки

Командная строка делится на *аргументы командной строки*, которые разделены пробельными символами (пробелом или табуляцией).
Первый аргумент присутствует всегда и представляет имя команды.
Остальные аргументы называются *аргументами команды* и передаются ей для разбора.
Они могут включать имена файловых объектов, идентификатор процесса, символьную строку.
Если аргумент содержит пробельный символ, который может разбить его на две части, то он заключается в кавычки.
Аргументы команды могут отсутствовать, тогда используются в зависимости от команды значения по умолчанию.

<!-- Пример с командой ls -->
Команда `ls`, запущенная без аргументов, перечисляет имена файлов и каталогов в текущем каталоге.
Если передать ей путь к каталогу, то она отобразит содержимое этого каталога:
```bash
woldemar@skt:~$ ls snap/
firefox  snapd-desktop-integration  snap-store
```
Если мы хотим посмотреть содержимое каталога "Рабочий стол", то его имя следует передать в кавычках, иначе это будет расценено как два пути:
```bash
woldemar@skt:~$ ls Рабочий стол
ls: невозможно получить доступ к 'Рабочий': Нет такого файла или каталога
ls: невозможно получить доступ к 'стол': Нет такого файла или каталога
```

<!-- Опции -->
Аргументы команды, начинающиеся с дефиса, называются *опциями*.
Они настраивают поведение команды: меняют формат вывода, переключают на другой режим работы.
Опции бывают короткими и длинными.
В названии короткой опции только один символ.
У длинных опций названия более подробные и предваряются уже двумя дефисами.
Одна и та же опция может иметь как короткое, так и длинное название.
Например, часто образуют пары опции:
* `-v` и `--version`;
* `-h` и `--help`;
* `-a` и `--all`.

<!-- Объединение коротких опций -->
Несколько коротких опций можно объедить, перечислив их однобуквенные обозначения после дефиса.
Опция `-a` в команде `ls` показывает скрытые объекты (имена которых начинается с символа точки), а опция `-l` выводит подробную информацию по каждому объекту.
Командная строка `ls -a -l` идентична строке `ls -al` и выводит на экран подробную информацию о файловых объектах, включая скрытые, в текущем каталоге.
Короткая опция `-a` можно заменить на длинную `--all`, тогда строка стала бы как `ls --all -l` и исполнила те же самые действия.

<!-- Опции с аргументами -->
Обычная опция представляет булевый аргумент и предлагает выбор из двух вариантов.
Также существуют опции с аргументами, которые можно сравнить с именованными параметрами в Python.
Опция от аргумента отделяется символом `=`.
Значения возможных аргументов может быть любым или выбранным из списка.
Именованная опция `--sort=WORD` команды `ls` указывает критерий сортировки файлов.
Аргумент `WORD` может быть выбран из списка `none`, `size`, `time`, `version`, `extension`.
Команда `ls --sort=size` отсортирует файлы в текущем каталоге по размеру.

<!-- Последовательность аргументов -->
Принято после имени команды перечислять опции и только потом остальные аргументы.
Следующая команда выведет содержимое каталога `work`, отсортированного по размеру (опция `--sort=size`) и указанием размера занимаемого места на диске (опция `-s`):
`ls -s --sort=size work`


## Управление строкой ввода

<!-- Введение -->

<!-- Системный редактор текстовой строки -->
Система UNIX при работе с терминалом предлагает минималистичный редактор строки.
Поэтому пользовательские программы не реализуют собственный ввод и редактирование данных, что упрощает их код.

<!-- Ограниченные возможности системного редактора -->
У системного редактора отсутствует управляемый курсор.
Курсор всегда привязан к концу редактируемой строки, поэтому добавление и удаление символов происходит только с конца.
Команды удаления, перемещающие курсор назад, могут затереть символ, слово или строку.
```
> command arg1 arg2_
  ┬           ┬   ┬│ Удаляет последние:
  │           │   └┤ `ctrl-?` символ
  │           └────┤ `ctrl-w` слово
  └────────────────┘ `ctrl-u` строку
```

По современным меркам вышеперечисленных команд недостаточно для полноценного редактирования.
В редакторе не хватает управления курсором, поддержки функциональных клавиш, истории команд, автодополнения.
Расширение системного редактора новыми функциональными возможностями выглядело бы абсурдно.
Его программный код размещается на стороне ядра ОС.
Это усложняет расширение и поддержку кода.
Функциональные возможности часто связаны с предпочтениями пользователя.
Пользователь хотел бы иметь выбор, а встроенный в ОС редактор этого не позволяет.
По этим причинам редактирование строки реализовано в интерпретаторе командной строки.

Интерпретатор `bash` предлагает свой редактор строки, основанный на библиотеке `GNU Readline`.
Если запустить `bash` с опцией `--noediting`, то он откажется от собственного редактора в пользу системного.
Это можно увидеть, если воспользоваться клавишами управления курсором.
Они теряют свои функции и генерируют символы `^[[A`, `^[[B`, `^[[C`, `^[[D`.

`bash` предлагает собственный редактор только для набора командной строки.
Если запустить утилиту, которая потребует данные от пользователя, то вступает в работу системный редактор.
Попробуйте запустить утилиту `sort`, которая по умолчанию сотртируемые записи, введенные из терминала.
Нажатие на `Enter` указывает на конец записи, а окончание ввода данных сигналиризуертся по `ctrl-d`.
```
woldemar@skt:~$ sort
огурец    <Enter>
банан     <Enter>
перец     <Enter>
помидор   <ctrl-d>
банан
огурец
перец
помидор
```

`bash` для редактирования строки использует комбинации клавиш, свойственные редактору `emacs`.
Пройдемся по следующим возможностям встроенного редактора `bash`:
* работу с историей команд;
* автодополнение;
* перемещение курсора по строке;
* удаление символов в строке;
* отмена изменений;
* вставка текста из буфера.

<!-- Поиск строки в истории команд -->
Выше упоминали встроенную команду `history`, которая выводит на экран список исполненных команд.
История команд каждого пользователя хранится в его домашнем каталоге в файле `.bash_history`.
Выбор предыдущей команды из истории клавишей «↓» (дублируется `ctrl-p`), а на следующу -- «↑» (`ctrl-n`).
Если команда расположена далеко, то ее можно найти поиском (инкрементальным и реверсивным).
Поиск активируется по `ctrl-r` и последующий набор текста приведет к выводу строки, в которой присутствует набранный текст.
Выход из поиска с последующим выбором активной строки происходит по нажатию на клавишу `ESC`.

```{figure} ./images/bash-history-prev-next.png
```

```{note}
Если запущенная командная строка начинается с пробела, то она не сохраняется в истории!
```

<!-- Автодополнение -->
При вводе в терминал команд и их параметров легко ошибиться.
Найти ошибку не всегда просто.
В этом случае помогает автодополнение.
Пользователь вводит начальные символы данных, а система по просьбе введет оставшиеся символы или предложит на выбор возможные варианты.
Это работает для названий команд, файлов и каталогов.
Текст дополняется, если однозначно, по клавише `tab`.
Если есть несколько вариантов дополнения, то двойное нажатие по `tab` предложит все возможные варианты.

<!-- Перемещение курсора -->
В редакторе строки от `Readline` присутствует курсор, который можно перемещать вперед и назад.
Перемещения курсора складываются из направления движения (вперед и назад) и дистанцию (на символ, слово и строку):
* на один символ вперед и назад (`ctrl-f`/`ctrl-b`);
* на одно слово вперед и назад (`alt-f`/`alt-b`);
* в начало и конец строки (`ctrl-a`/`ctrl-e`).

```{figure} ./images/bash-cursor-move.png
```

Горячие клавиши отложатся в памяти быстрее, если знать, что `f` образован от слова `forward` (вперед), а `b` -- `back` (назад).

<!-- Отмена изменений -->
Прежде чем перейти к удалению и вставке, научимся отменять изменения.
Это понадобится, чтобы вернуть в исходное состояние строку для упражнений без его повторного набора.
Известная всем команда `ctrl-z` в `emacs` имеет вид `ctrl-_` или `ctrl-x ctrl-u`.

<!-- Удаление текста -->
Для удаления используют следующие горячие клавиши:
* `ctrl-d` -- символа под курсором (аналог клавиши `del`);
* `ctrl-k` -- от начала курсора до конца строки;
* `ctrl-u` -- от начала курсора до начала строки;
* `alt-d`  -- от начала курсора до конца слова;
* `alt-backspace` -- от курсора до начала слова;
* `ctrl-w` -- от курсора до предыдущего пробела.

Команда `ctrl-w` полезна для удаления ровно одного аргумента в строке.
Команда `ctrl-u` позволяет быстро очистить командную строку, чем если пробовать это через `Backspace`.

```{figure} ./images/bash-remove-cmdline.png
```

<!-- Вставка текста -->
Удаляемый текст помещается в буфер.
Предыдущий текст при этом не перезатирается, а сдвигается ниже, т.е. буфер многоуровневый.
Команда `ctrl-y` вставляет текст из вершины буфера.
Если нужно вставить текст из другой ячейки буфера, то его прокручивают командой `alt-y`.
Направление прокрутки меняют на противоположную командой `alt--` (знак-аргумент), а число прокрутки `alt-number` (число-аргумент).
Работа с многоуровневым буфером заставляет пользователя помнить занесенные туда текстовые фрагменты и их позиции.
Это не делает популярной команду вставки.
На практике вместо вставки заново набирают строку или используют следующий трюк.
Перед длинной командой добавляют символ решетки `#` и нажимают `Enter`.
Такая команда не исполнится, но сохранится в истории, откуда ее можно быстро выбрать и отредактировать.

 <!--
* Alt + T
* Alt + .
 -->

<!-- Заключение раздела -->
Перечисленные выше команды совпадают с принятыми в текстовом редакторе `emacs`.
Полный список команд вы можете найти по ссылке ["Emacs Editing Mode Cheat Sheet"](https://catonmat.net/ftp/readline-emacs-editing-mode-cheat-sheet.txt).
Существует и альтернативные команды в стиле `vi`.
Переключение между ними происходит по встроенной команде `set`:
```bash
set -o emacs
set -o vi
```


## Вопросы для контроля

1. В каких случаях вам понадобится умение работать в командной строке?
1. Расскажите про формат командной строки.
1. Чем отличаются редакторы строки: системный и встроенный в `bash`?
1. Как использовать с пользой историю команд?
1. Что такое автодополнение? Продемонстрируйте на примере.
1. Как можно быстро перемещать курсор по редактируемой командной строке?
1. Перечислите не менее двух команд по удалению символов строки в `bash`.
1. Как работает вставка при редактировании командной строки?
1. Как отменить последнее изменение строки?
1. Чем отличаются команды `alt-backspace` и `ctrl-w`?
   В каких случаях они применяются?
1. Как исключить попадание выполненной команды в историю?


## Упражнения

1. Исправьте строку `sudo docker run sppo --volume $(pwd):/book --rm`, переместив аргумент `sppo` в конец.
   В начальной позиции курсор расположен в конце строки.
   Постарайтесь воспользоваться как можно меньшим количеством команд для этого.
1. В следующей командной строке поменяйте свободные аргументы местами: <!-- https://unix.stackexchange.com/questions/187600/how-do-i-swap-the-two-last-command-line-arguments -->
   ```
   diff -u myproject/src/lib/file.cpp ~/Downloads/file_from_ivanov.cpp
   ```
   Постарайтесь воспользоваться как можно меньшим количеством команд для этого.
1. В следующей командной строке поменяйте опции местами:
   ```
   tar -f -x ~/myproject/build/archive.tar
   ```
   Постарайтесь воспользоваться как можно меньшим количеством команд для этого.
1. Попробуйте разобраться, что делает каждая из опций в команде `ls -l --sort=size --reverse`?
1. С помощью автодополнения покажите все команды, начинающиеся с символов `a`, `b`, ... `z`.
